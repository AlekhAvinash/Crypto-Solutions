from pwn import *
import binascii
from Crypto.Util.Padding import pad, unpad
from string import printable

byte_xor = lambda ba1, ba2: bytes([_a ^ _b for _a, _b in zip(ba1, ba2)])

# all possible combinations of plaintext blocks and encrypted IV
possible_ct_blocks = []

# the most likely third and final block
third_block = pad(b'a' * 32 + b'}', 16)[-16:]

# the flag
flag = [b'',b'', third_block]

# finds all the values of the first block in the ciphertext
while True:
	s = remote('jh2i.com', 50028)
	ct_block = binascii.unhexlify(s.recvline().decode('utf-8')[:-1])[:16]
	s.close()
	if ct_block not in possible_ct_blocks:
		possible_ct_blocks += [ct_block]
	if len(possible_ct_blocks) == 3:
		break

# decrypts the data using knowladge of the third block and the posibility of it being in every position
for j in range(3):
	xorred_block = bytes(byte_xor(possible_ct_blocks[j], possible_ct_blocks[(j + 1) % 3]))
	xorred_block = byte_xor(xorred_block, third_block)
	if all(chr(c) in printable for c in xorred_block):
		if b'flag' in xorred_block:
			flag[0] = xorred_block
		else:
			flag[1] = xorred_block


print(unpad(b''.join(flag), 16).decode('utf-8'))